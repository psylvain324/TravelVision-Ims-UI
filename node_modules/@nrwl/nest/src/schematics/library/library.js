"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
const ts = require("typescript");
const ast_utils_1 = require("@nrwl/workspace/src/utils/ast-utils");
function default_1(schema) {
    return (host, context) => {
        const options = normalizeOptions(host, schema);
        return schematics_1.chain([
            schematics_1.externalSchematic('@nrwl/node', 'lib', schema),
            createFiles(options),
            addExportsToBarrelFile(options),
            updateTsConfig(options),
            addProject(options),
            workspace_1.formatFiles(options),
            workspace_1.deleteFile(`/${options.projectRoot}/src/lib/${options.fileName}.spec.ts`),
            workspace_1.deleteFile(`/${options.projectRoot}/src/lib/${options.fileName}.ts`),
        ]);
    };
}
exports.default = default_1;
function normalizeOptions(host, options) {
    const defaultPrefix = workspace_1.getNpmScope(host);
    const name = workspace_1.toFileName(options.name);
    const projectDirectory = options.directory
        ? `${workspace_1.toFileName(options.directory)}/${name}`
        : name;
    const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');
    const fileName = projectName;
    const projectRoot = core_1.normalize(`${ast_utils_1.libsDir(host)}/${projectDirectory}`);
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    const normalized = Object.assign(Object.assign({}, options), { prefix: defaultPrefix, // we could also allow customizing this
        fileName, name: projectName, projectRoot,
        projectDirectory,
        parsedTags });
    return normalized;
}
function addExportsToBarrelFile(options) {
    return (host) => {
        const indexFilePath = `${options.projectRoot}/src/index.ts`;
        const buffer = host.read(indexFilePath);
        if (!!buffer) {
            const indexSource = buffer.toString('utf-8');
            const indexSourceFile = ts.createSourceFile(indexFilePath, indexSource, ts.ScriptTarget.Latest, true);
            workspace_1.insert(host, indexFilePath, [
                new ast_utils_1.RemoveChange(indexFilePath, 0, `export * from './lib/${options.fileName}';`),
                ...workspace_1.addGlobal(indexSourceFile, indexFilePath, `export * from './lib/${options.fileName}.module';`),
                ...(options.service
                    ? workspace_1.addGlobal(indexSourceFile, indexFilePath, `export * from './lib/${options.fileName}.service';`)
                    : []),
                ...(options.controller
                    ? workspace_1.addGlobal(indexSourceFile, indexFilePath, `export * from './lib/${options.fileName}.controller';`)
                    : []),
            ]);
        }
    };
}
function createFiles(options) {
    return schematics_1.mergeWith(schematics_1.apply(schematics_1.url(`./files/lib`), [
        schematics_1.template(Object.assign(Object.assign(Object.assign({}, options), workspace_1.names(options.name)), { tmpl: '', offsetFromRoot: workspace_1.offsetFromRoot(options.projectRoot) })),
        schematics_1.move(options.projectRoot),
        options.unitTestRunner === 'none'
            ? schematics_1.filter((file) => !file.endsWith('spec.ts'))
            : schematics_1.noop(),
        options.publishable
            ? schematics_1.noop()
            : schematics_1.filter((file) => !file.endsWith('package.json')),
        options.service
            ? schematics_1.noop()
            : schematics_1.filter((file) => !file.endsWith('.service.ts')),
        options.controller
            ? schematics_1.noop()
            : schematics_1.filter((file) => !file.endsWith('.controller.ts')),
        !options.controller || options.unitTestRunner === 'none'
            ? schematics_1.filter((file) => !file.endsWith('.controller.spec.ts'))
            : schematics_1.noop(),
        !options.service || options.unitTestRunner === 'none'
            ? schematics_1.filter((file) => !file.endsWith('.service.spec.ts'))
            : schematics_1.noop(),
    ]), schematics_1.MergeStrategy.Overwrite);
}
function updateTsConfig(options) {
    return (host, context) => {
        const projectConfig = workspace_1.getProjectConfig(host, options.name);
        return workspace_1.updateJsonInTree(`${projectConfig.root}/tsconfig.lib.json`, (json) => {
            json.compilerOptions.target = options.target;
            return json;
        });
    };
}
function addProject(options) {
    if (!options.publishable && !options.buildable) {
        return schematics_1.noop();
    }
    return workspace_1.updateWorkspaceInTree((json, context, host) => {
        const architect = json.projects[options.name].architect;
        if (architect) {
            architect.build = {
                builder: '@nrwl/node:package',
                options: {
                    outputPath: `dist/${ast_utils_1.libsDir(host)}/${options.projectDirectory}`,
                    tsConfig: `${options.projectRoot}/tsconfig.lib.json`,
                    packageJson: `${options.projectRoot}/package.json`,
                    main: `${options.projectRoot}/src/index.ts`,
                    assets: [`${options.projectRoot}/*.md`],
                },
            };
        }
        return json;
    });
}
//# sourceMappingURL=library.js.map